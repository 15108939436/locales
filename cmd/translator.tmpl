{{ define "translator" }}
package {{ .Locale }}

import (
	"math"

	"github.com/go-playground/locales"
	"github.com/go-playground/locales/currency"
)

type {{ .Locale }} struct {
	locale     			   string
	pluralsCardinal 	   []locales.PluralRule
	pluralsOrdinal  	   []locales.PluralRule
	decimal    			   []byte
	group      			   []byte
	minus      			   []byte
	percent    			   []byte
	percentPrefix   	   []byte
	percentSuffix   	   []byte
	perMille   			   []byte
	currencies 			   [][]byte // idx = enum of currency code
	currencyPositivePrefix []byte
	currencyPositiveSuffix []byte
	currencyNegativePrefix []byte
	currencyNegativeSuffix []byte
	monthsAbbreviated      [][]byte
	monthsNarrow      	   [][]byte
	monthsShort      	   [][]byte
	monthsWide      	   [][]byte
	daysAbbreviated        [][]byte
	daysNarrow      	   [][]byte
	daysShort      	   	   [][]byte
	daysWide      	   	   [][]byte
	periodsAbbreviated     [][]byte
	periodsNarrow      	   [][]byte
	periodsShort      	   [][]byte
	periodsWide      	   [][]byte
	erasAbbreviated        [][]byte
	erasNarrow      	   [][]byte
	erasWide      	   	   [][]byte
}

// New returns a new instance of translator for the '{{ .Locale }}' locale
func New() locales.Translator {
	return &{{ .Locale }}{
		locale:   		 "{{ .Locale }}",
		pluralsCardinal: {{ .Plurals }},
		pluralsOrdinal:  {{ .PluralsOrdinal }},
		decimal:  		 {{ .Decimal }},
		group:    		 {{ .Group }},
		minus:    		 {{ .Minus }},
		percent:  		 {{ .Percent }},
		perMille:        {{ .PerMille }},
		currencies:      {{ .Currencies }},
		{{- if gt (len .FmtPercentPrefix) 0}}
		percentPrefix:   {{ .FmtPercentPrefix }},
		{{- end -}}
		{{- if gt (len .FmtPercentSuffix) 0}}
		percentSuffix:   {{ .FmtPercentSuffix }},
		{{- end -}}
		{{- if gt (len .FmtCurrencyPrefix) 0}}
		currencyPositivePrefix:   {{ .FmtCurrencyPrefix }},
		{{- end -}}
		{{- if gt (len .FmtCurrencySuffix) 0}}
		currencyPositiveSuffix:   {{ .FmtCurrencySuffix }},
		{{- end -}}
		{{- if gt (len .FmtCurrencyNegativePrefix) 0}}
		currencyNegativePrefix:   {{ .FmtCurrencyNegativePrefix }},
		{{- end -}}
		{{- if gt (len .FmtCurrencyNegativeSuffix) 0}}
		currencyNegativeSuffix:   {{ .FmtCurrencyNegativeSuffix }},
		{{- end -}}
		{{- if gt (len .FmtMonthsAbbreviated) 0 }}
		monthsAbbreviated:   {{ .FmtMonthsAbbreviated }},
		{{- end -}}
		{{- if gt (len .FmtMonthsNarrow) 0 }}
		monthsNarrow:   {{ .FmtMonthsNarrow }},
		{{- end -}}
		{{- if gt (len .FmtMonthsShort) 0 }}
		monthsShort:   {{ .FmtMonthsShort }},
		{{- end -}}
		{{- if gt (len .FmtMonthsWide) 0 }}
		monthsWide:   {{ .FmtMonthsWide }},
		{{- end -}}
		{{- if gt (len .FmtDaysAbbreviated) 0 }}
		daysAbbreviated:   {{ .FmtDaysAbbreviated }},
		{{- end -}}
		{{- if gt (len .FmtDaysNarrow) 0 }}
		daysNarrow:   {{ .FmtDaysNarrow }},
		{{- end -}}
		{{- if gt (len .FmtDaysShort) 0 }}
		daysShort:   {{ .FmtDaysShort }},
		{{- end -}}
		{{- if gt (len .FmtDaysWide) 0 }}
		daysWide:   {{ .FmtDaysWide }},
		{{- end -}}
		{{- if gt (len .FmtPeriodsAbbreviated) 0 }}
		periodsAbbreviated:   {{ .FmtPeriodsAbbreviated }},
		{{- end -}}
		{{- if gt (len .FmtPeriodsNarrow) 0 }}
		periodsNarrow:   {{ .FmtPeriodsNarrow }},
		{{- end -}}
		{{- if gt (len .FmtPeriodsShort) 0 }}
		periodsShort:   {{ .FmtPeriodsShort }},
		{{- end -}}
		{{- if gt (len .FmtPeriodsWide) 0 }}
		periodsWide:   {{ .FmtPeriodsWide }},
		{{- end -}}
		{{- if gt (len .FmtErasAbbreviated) 0 }}
		erasAbbreviated:   {{ .FmtErasAbbreviated }},
		{{- end -}}
		{{- if gt (len .FmtErasNarrow) 0 }}
		erasNarrow:   {{ .FmtErasNarrow }},
		{{- end -}}
		{{- if gt (len .FmtErasWide) 0 }}
		erasWide:   {{ .FmtErasWide }},
		{{- end -}}
	}
}

// Locale returns the current translators string locale
func({{ .BaseLocale }} *{{ .Locale }}) Locale() string {
	return {{ .BaseLocale }}.locale
}

// PluralsCardinal returns the list of cardinal plural rules associated with '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) PluralsCardinal() []locales.PluralRule {
	return {{ .BaseLocale }}.pluralsCardinal
}

// PluralsOrdinal returns the list of ordinal plural rules associated with '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) PluralsOrdinal() []locales.PluralRule {
	return {{ .BaseLocale }}.pluralsOrdinal
}

// CardinalPluralRule returns the cardinal PluralRule given 'num' and digits/precision of 'v' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) CardinalPluralRule(num float64, v uint64) locales.PluralRule {
	{{ .CardinalFunc }}
}

// OrdinalPluralRule returns the ordinal PluralRule given 'num' and digits/precision of 'v' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) OrdinalPluralRule(num float64, v uint64) locales.PluralRule {
	{{ .OrdinalFunc }}
}

// RangePluralRule returns the ordinal PluralRule given 'num1', 'num2' and digits/precision of 'v1' and 'v2' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) RangePluralRule(num1 float64, v1 uint64,num2 float64, v2 uint64) locales.PluralRule {
	{{ .RangeFunc }}
}

// FmtNumber returns 'num' with digits/precision of 'v' for '{{ .Locale }}' and handles both Whole and Real numbers based on 'v'
// returned as a []byte just in case the caller wishes to add more and can help
// avoid allocations; otherwise just cast as string.
func({{ .BaseLocale }} *{{ .Locale }}) FmtNumber(num float64, v uint64) []byte {

	s := strconv.FormatFloat(math.Abs(num), 'f', int(v), 64)
	{{- if eq .FmtNumberExists true }}
	{{- if gt .FmtNumberGroupLen 0 }}
	l := len(s) + len({{ .BaseLocale }}.decimal) + len({{ .BaseLocale }}.group) * len(s[:len(s)-int(v)-1]) / {{ .FmtNumberGroupLen }}
	count := 0
	inWhole := v == 0
	{{- if gt .FmtNumberSecondaryGroupLen 0}}
	inSecondary := false
	groupThreshold := {{ .FmtNumberGroupLen }}
	{{ end -}}
	{{ else }}
	l := len(s) + len({{ .BaseLocale }}.decimal)
	{{ end }}
	b := make([]byte, 0, l)

	for i := len(s) - 1; i >= 0; i-- {

		if s[i] == '.' {

			{{- if eq .DecimalLen 1 }}
			b = append(b, {{ .BaseLocale }}.decimal[0])
			{{- else }}
			for j := len({{ .BaseLocale }}.decimal) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.decimal[j])
			}
			{{ end -}}
			{{- if gt .FmtNumberGroupLen 0 }}
			inWhole = true
			{{- end }}
			continue
		}

		{{ if gt .FmtNumberGroupLen 0 }}
		if inWhole {

			{{- if gt .FmtNumberSecondaryGroupLen 0}}
			
			if count == groupThreshold {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1

				if !inSecondary {
					inSecondary = true
					groupThreshold = {{ .FmtNumberSecondaryGroupLen }}
				}
			{{ else }}
			if count == {{ .FmtNumberGroupLen }} {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1
			{{ end -}}
			} else {
				count++
			}
		}

		{{ end }}

		b = append(b, s[i])
	}

	if num < 0 {
		{{- if eq .MinusLen 1 }}
		b = append(b, {{ .BaseLocale }}.minus[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.minus) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.minus[j])
		}
		{{ end -}}
	}

	// reverse
	for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
		b[i], b[j] = b[j], b[i]
	}

	{{ if gt .FmtNumberMinDecimalLen 0 }}
	if int(v) < {{ .FmtNumberMinDecimalLen }} {

		if v == 0 {
			b = append(b, {{ .BaseLocale }}.decimal...)
		}

		for i := 0; i < {{ .FmtNumberMinDecimalLen }}-int(v); i++ {
			b = append(b, '0')
		}
	}
	{{ end }}

	return b
	{{ else }}
	return []byte(s)
	{{ end -}}
}

// FmtPercent returns 'num' with digits/precision of 'v' for '{{ .Locale }}' and handles both Whole and Real numbers based on 'v'
// returned as a []byte just in case the caller wishes to add more and can help
// avoid allocations; otherwise just cast as string.
// NOTE: 'num' passed into FmtPercent is assumed to be in percent already
func({{ .BaseLocale }} *{{ .Locale }}) FmtPercent(num float64, v uint64) []byte {

	s := strconv.FormatFloat(math.Abs(num), 'f', int(v), 64)
	{{- if eq .FmtPercentExists true }}
	{{- if gt .FmtPercentGroupLen 0 }}
	l := len(s) + len({{ .BaseLocale }}.decimal) + len({{ .BaseLocale }}.group) * len(s[:len(s)-int(v)-1]) / {{ .FmtPercentGroupLen }}
	count := 0
	inWhole := v == 0
	{{- if gt .FmtPercentSecondaryGroupLen 0}}
	inSecondary := false
	groupThreshold := {{ .FmtPercentGroupLen }}
	{{ end -}}
	{{ else }}
	l := len(s) + len({{ .BaseLocale }}.decimal)
	{{- end }}
	b := make([]byte, 0, l)

	for i := len(s) - 1; i >= 0; i-- {

		if s[i] == '.' {

			{{- if eq .DecimalLen 1 }}
			b = append(b, {{ .BaseLocale }}.decimal[0])
			{{- else }}
			for j := len({{ .BaseLocale }}.decimal) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.decimal[j])
			}
			{{ end -}}
			{{- if gt .FmtPercentGroupLen 0 }}
			inWhole = true
			{{ end }}
			continue
		}

		{{ if gt .FmtPercentGroupLen 0 }}
		if inWhole {

			{{- if gt .FmtPercentSecondaryGroupLen 0}}
			
			if count == groupThreshold {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1

				if !inSecondary {
					inSecondary = true
					groupThreshold = {{ .FmtPercentSecondaryGroupLen }}
				}
			{{ else }}
			if count == {{ .FmtPercentGroupLen }} {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1
			{{ end -}}
			} else {
				count++
			}
		}

		{{ end }}

		b = append(b, s[i])
	}

	if num < 0 {
		{{- if eq .MinusLen 1 }}
		b = append(b, {{ .BaseLocale }}.minus[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.minus) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.minus[j])
		}
		{{ end -}}
	}

	{{ if and .FmtPercentInPrefix (not .FmtPercentLeft) }}
		{{- if eq .PercentLen 1 }}
		b = append(b, {{ .BaseLocale }}.percent[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.percent) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.percent[j])
		}
		{{ end }}
	{{ end }}

	{{ if gt (len .FmtPercentPrefix) 0}}
		{{- if eq (len .FmtPercentPrefix) 1 }}
		b = append(b, {{ .BaseLocale }}.percentPrefix[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.percentPrefix) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.percentPrefix[j])
		}
		{{ end }}
	{{ end }}

	{{ if and .FmtPercentInPrefix .FmtPercentLeft }}
		{{- if eq .PercentLen 1 }}
		b = append(b, {{ .BaseLocale }}.percent[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.percent) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.percent[j])
		}
		{{ end }}
	{{ end }}

	// reverse
	for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
		b[i], b[j] = b[j], b[i]
	}

	{{ if gt .FmtPercentMinDecimalLen 0 }}
	if int(v) < {{ .FmtPercentMinDecimalLen }} {

		if v == 0 {
			b = append(b, {{ .BaseLocale }}.decimal...)
		}

		for i := 0; i < {{ .FmtPercentMinDecimalLen }}-int(v); i++ {
			b = append(b, '0')
		}
	}
	{{ end }}

	{{ if and (not .FmtPercentInPrefix) .FmtPercentLeft }}
		b = append(b, {{ .BaseLocale }}.percent...)
	{{ end }}

	{{ if gt (len .FmtPercentSuffix) 0}}
		b = append(b, {{ .BaseLocale }}.percentSuffix...)
	{{ end }}

	{{ if and (not .FmtPercentInPrefix) (not .FmtPercentLeft) }}
		b = append(b, {{ .BaseLocale }}.percent...)
	{{ end }}

	return b
	{{ else }}
	return []byte(s)
	{{ end -}}
}

// FmtCurrency returns the currency representation of 'num' with digits/precision of 'v' for '{{ .Locale }}'
// returned as a []byte just in case the caller wishes to add more and can help
// avoid allocations; otherwise just cast as string.
func({{ .BaseLocale }} *{{ .Locale }}) FmtCurrency(num float64, v uint64, currency currency.Type) []byte {
	
	s := strconv.FormatFloat(math.Abs(num), 'f', int(v), 64)
	symbol := {{ .BaseLocale }}.currencies[currency]
	{{- if eq .FmtCurrencyExists true }}
	{{- if gt .FmtCurrencyGroupLen 0 }}
	l := len(s) + len({{ .BaseLocale }}.decimal) + len({{ .BaseLocale }}.group) * len(s[:len(s)-int(v)-1]) / {{ .FmtCurrencyGroupLen }}
	count := 0
	inWhole := v == 0
	{{- if gt .FmtCurrencySecondaryGroupLen 0}}
	inSecondary := false
	groupThreshold := {{ .FmtCurrencyGroupLen }}
	{{ end -}}
	{{ else }}
	l := len(s) + len({{ .BaseLocale }}.decimal)
	{{ end }}
	b := make([]byte, 0, l)

	for i := len(s) - 1; i >= 0; i-- {

		if s[i] == '.' {

			{{- if eq .DecimalLen 1 }}
			b = append(b, {{ .BaseLocale }}.decimal[0])
			{{- else }}
			for j := len({{ .BaseLocale }}.decimal) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.decimal[j])
			}
			{{ end -}}
			{{- if gt .FmtCurrencyGroupLen 0 }}
			inWhole = true
			{{- end }}
			continue
		}

		{{ if gt .FmtCurrencyGroupLen 0 }}
		if inWhole {

			{{- if gt .FmtCurrencySecondaryGroupLen 0}}
			
			if count == groupThreshold {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1

				if !inSecondary {
					inSecondary = true
					groupThreshold = {{ .FmtCurrencySecondaryGroupLen }}
				}
			{{ else }}
			if count == {{ .FmtCurrencyGroupLen }} {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1
			{{ end -}}
			} else {
				count++
			}
		}

		{{ end }}

		b = append(b, s[i])
	}

	{{ if and .FmtCurrencyInPrefix (not .FmtCurrencyLeft) }}
		for j := len(symbol) - 1; j >= 0; j-- {
			b = append(b, symbol[j])
		}
	{{ end }}

	{{ if gt (len .FmtCurrencyPrefix) 0}}
		{{- if eq (len .FmtCurrencyPrefix) 1 }}
		b = append(b, {{ .BaseLocale }}.currencyPositivePrefix[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.currencyPositivePrefix) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.currencyPositivePrefix[j])
		}
		{{ end }}
	{{ end }}

	{{ if and .FmtCurrencyInPrefix .FmtCurrencyLeft }}
		for j := len(symbol) - 1; j >= 0; j-- {
			b = append(b, symbol[j])
		}
	{{ end }}

	if num < 0 {
		{{- if eq .MinusLen 1 }}
		b = append(b, {{ .BaseLocale }}.minus[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.minus) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.minus[j])
		}
		{{ end -}}
	}

	// reverse
	for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
		b[i], b[j] = b[j], b[i]
	}

	{{ if gt .FmtCurrencyMinDecimalLen 0 }}
	if int(v) < {{ .FmtCurrencyMinDecimalLen }} {

		if v == 0 {
			b = append(b, {{ .BaseLocale }}.decimal...)
		}

		for i := 0; i < {{ .FmtCurrencyMinDecimalLen }}-int(v); i++ {
			b = append(b, '0')
		}
	}
	{{ end }}

	{{ if and (not .FmtCurrencyInPrefix) .FmtCurrencyLeft }}
		b = append(b, symbol...)
	{{ end }}

	{{ if gt (len .FmtCurrencySuffix) 0}}
		b = append(b, {{ .BaseLocale }}.currencyPositiveSuffix...)
	{{ end }}

	{{ if and (not .FmtCurrencyInPrefix) (not .FmtCurrencyLeft) }}
		b = append(b, symbol...)
	{{ end }}

	return b
	{{ else }}
	return append(append([]byte{}, symbol...), s...)
	{{ end -}}
}

// FmtAccounting returns the currency representation of 'num' with digits/precision of 'v' for '{{ .Locale }}'
// in accounting notation. returned as a []byte just in case the caller wishes to add more and can help
// avoid allocations; otherwise just cast as string.
func({{ .BaseLocale }} *{{ .Locale }}) FmtAccounting(num float64, v uint64, currency currency.Type) []byte {
	
	s := strconv.FormatFloat(math.Abs(num), 'f', int(v), 64)
	symbol := {{ .BaseLocale }}.currencies[currency]
	{{- if eq .FmtCurrencyExists true }}
	{{- if gt .FmtCurrencyGroupLen 0 }}
	l := len(s) + len({{ .BaseLocale }}.decimal) + len({{ .BaseLocale }}.group) * len(s[:len(s)-int(v)-1]) / {{ .FmtCurrencyGroupLen }}
	count := 0
	inWhole := v == 0
	{{- if gt .FmtCurrencySecondaryGroupLen 0}}
	inSecondary := false
	groupThreshold := {{ .FmtCurrencyGroupLen }}
	{{ end -}}
	{{ else }}
	l := len(s) + len({{ .BaseLocale }}.decimal)
	{{ end }}
	b := make([]byte, 0, l)

	for i := len(s) - 1; i >= 0; i-- {

		if s[i] == '.' {

			{{- if eq .DecimalLen 1 }}
			b = append(b, {{ .BaseLocale }}.decimal[0])
			{{- else }}
			for j := len({{ .BaseLocale }}.decimal) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.decimal[j])
			}
			{{ end -}}
			{{- if gt .FmtCurrencyGroupLen 0 }}
			inWhole = true
			{{- end }}
			continue
		}

		{{ if gt .FmtCurrencyGroupLen 0 }}
		if inWhole {

			{{- if gt .FmtCurrencySecondaryGroupLen 0}}
			
			if count == groupThreshold {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1

				if !inSecondary {
					inSecondary = true
					groupThreshold = {{ .FmtCurrencySecondaryGroupLen }}
				}
			{{ else }}
			if count == {{ .FmtCurrencyGroupLen }} {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1
			{{ end -}}
			} else {
				count++
			}
		}

		{{ end }}

		b = append(b, s[i])
	}

	if num < 0 {

		{{ if and .FmtCurrencyNegativeInPrefix (not .FmtCurrencyNegativeLeft) }}
		for j := len(symbol) - 1; j >= 0; j-- {
			b = append(b, symbol[j])
		}
		{{ end }}

		{{ if gt (len .FmtCurrencyNegativePrefix) 0}}
			{{- if eq (len .FmtCurrencyNegativePrefix) 1 }}
			b = append(b, {{ .BaseLocale }}.currencyNegativePrefix[0])
			{{ else }}
			for j := len({{ .BaseLocale }}.currencyNegativePrefix) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.currencyNegativePrefix[j])
			}
			{{ end }}
		{{ end }}

		{{ if and .FmtCurrencyNegativeInPrefix .FmtCurrencyNegativeLeft }}
			for j := len(symbol) - 1; j >= 0; j-- {
				b = append(b, symbol[j])
			}
		{{ end }}

		{{ if eq (not .FmtCurrencyNegativeExists) true}}
			{{- if eq .MinusLen 1 }}
			b = append(b, {{ .BaseLocale }}.minus[0])
			{{ else }}
			for j := len({{ .BaseLocale }}.minus) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.minus[j])
			}
			{{ end -}}
		{{ end }}

	{{ if or .FmtCurrencyInPrefix (gt (len .FmtCurrencyPrefix) 0) }}
	} else {
	{{ end }}
		
		{{ if and .FmtCurrencyInPrefix (not .FmtCurrencyLeft) }}
		for j := len(symbol) - 1; j >= 0; j-- {
			b = append(b, symbol[j])
		}
		{{ end }}

		{{ if gt (len .FmtCurrencyPrefix) 0}}
			{{- if eq (len .FmtCurrencyPrefix) 1 }}
			b = append(b, {{ .BaseLocale }}.currencyPositivePrefix[0])
			{{ else }}
			for j := len({{ .BaseLocale }}.currencyPositivePrefix) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.currencyPositivePrefix[j])
			}
			{{ end }}
		{{ end }}

		{{ if and .FmtCurrencyInPrefix .FmtCurrencyLeft }}
			for j := len(symbol) - 1; j >= 0; j-- {
				b = append(b, symbol[j])
			}
		{{- end }}
	}

	// reverse
	for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
		b[i], b[j] = b[j], b[i]
	}

	{{ if gt .FmtCurrencyMinDecimalLen 0 }}
	if int(v) < {{ .FmtCurrencyMinDecimalLen }} {

		if v == 0 {
			b = append(b, {{ .BaseLocale }}.decimal...)
		}

		for i := 0; i < {{ .FmtCurrencyMinDecimalLen }}-int(v); i++ {
			b = append(b, '0')
		}
	}
	{{- end }}

	{{ if or (not .FmtCurrencyNegativeInPrefix) (gt (len .FmtCurrencyNegativeSuffix) 0)}}
	if num < 0 {
	{{- end }}
		{{- if and (not .FmtCurrencyNegativeInPrefix) .FmtCurrencyNegativeLeft }}
			b = append(b, symbol...)
		{{- end -}}

		{{- if gt (len .FmtCurrencyNegativeSuffix) 0}}
			b = append(b, {{ .BaseLocale }}.currencyNegativeSuffix...)
		{{- end -}}

		{{- if and (not .FmtCurrencyNegativeInPrefix) (not .FmtCurrencyNegativeLeft) }}
			b = append(b, symbol...)
		{{- end -}}
	{{ if or (not .FmtCurrencyInPrefix) (gt (len .FmtCurrencySuffix) 0)}}
	} else {
	{{ end }}
		{{- if and (not .FmtCurrencyInPrefix) .FmtCurrencyLeft }}
			b = append(b, symbol...)
		{{- end -}}

		{{- if gt (len .FmtCurrencySuffix) 0}}
			b = append(b, {{ .BaseLocale }}.currencyPositiveSuffix...)
		{{- end -}}

		{{- if and (not .FmtCurrencyInPrefix) (not .FmtCurrencyLeft) }}
			b = append(b, symbol...)
		{{- end -}}
	{{- if or (not .FmtCurrencyNegativeInPrefix) (gt (len .FmtCurrencyNegativeSuffix) 0)}}
	}
	{{- end }}

	return b
	{{ else }}
	return append(append([]byte{}, symbol...), s...)
	{{ end -}}
}

{{ end }}