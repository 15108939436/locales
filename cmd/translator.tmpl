{{ define "translator" }}
package {{ .Locale }}

import (
	"math"

	"github.com/go-playground/locales"
)

type {{ .Locale }} struct {
	locale     		string
	pluralsCardinal []locales.PluralRule
	pluralsOrdinal  []locales.PluralRule
	decimal    		[]byte
	group      		[]byte
	minus      		[]byte
	percent    		[]byte
	perMille   		[]byte
	currencies 		[][]byte // idx = enum of currency code
}

// New returns a new instance of translator for the '{{ .Locale }}' locale
func New() locales.Translator {
	return &{{ .Locale }}{
		locale:   		 "{{ .Locale }}",
		pluralsCardinal: {{ .Plurals }},
		pluralsOrdinal:  {{ .PluralsOrdinal }},
		decimal:  		 {{ .Decimal }},
		group:    		 {{ .Group }},
		minus:    		 {{ .Minus }},
		percent:  		 {{ .Percent }},
		perMille:        {{ .PerMille }},
		currencies:      {{ .Currencies }},
	}
}

// Locale returns the current translators string locale
func({{ .BaseLocale }} *{{ .Locale }}) Locale() string {
	return {{ .BaseLocale }}.locale
}

// PluralsCardinal returns the list of cardinal plural rules associated with '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) PluralsCardinal() []locales.PluralRule {
	return {{ .BaseLocale }}.pluralsCardinal
}

// PluralsOrdinal returns the list of ordinal plural rules associated with '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) PluralsOrdinal() []locales.PluralRule {
	return {{ .BaseLocale }}.pluralsOrdinal
}

// CardinalPluralRule returns the cardinal PluralRule given 'num' and digits/precision of 'v' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) CardinalPluralRule(num float64, v uint64) locales.PluralRule {
	{{ .CardinalFunc }}
}

// OrdinalPluralRule returns the ordinal PluralRule given 'num' and digits/precision of 'v' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) OrdinalPluralRule(num float64, v uint64) locales.PluralRule {
	{{ .OrdinalFunc }}
}

// RangePluralRule returns the ordinal PluralRule given 'num1', 'num2' and digits/precision of 'v1' and 'v2' for '{{ .Locale }}'
func({{ .BaseLocale }} *{{ .Locale }}) RangePluralRule(num1 float64, v1 uint64,num2 float64, v2 uint64) locales.PluralRule {
	{{ .RangeFunc }}
}

// FmtNumber returns 'num' with digits/precision of 'v' for '{{ .Locale }}' and handles both Whole and Real numbers based on 'v'
// returned as a []byte just in case the caller wishes to add more and can help
// avoid allocations; otherwise just cast as string.
func({{ .BaseLocale }} *{{ .Locale }}) FmtNumber(num float64, v uint64) []byte {

	s := strconv.FormatFloat(math.Abs(num), 'f', int(v), 64)
	{{- if eq .FmtNumberExists true }}
	{{- if gt .FmtNumberGroupLen 0 }}
	l := len(s) + len({{ .BaseLocale }}.decimal) + len({{ .BaseLocale }}.group) * len(s[:len(s)-int(v)-1]) / {{ .FmtNumberGroupLen }}
	count := 0
	inWhole := v == 0
	{{- if gt .FmtNumberSecondaryGroupLen 0}}
	inSecondary := false
	groupThreshold := {{ .FmtNumberGroupLen }}
	{{ end -}}
	{{ else }}
	l := len(s) + len({{ .BaseLocale }}.decimal)
	{{ end }}
	b := make([]byte, 0, l)

	for i := len(s) - 1; i >= 0; i-- {

		if s[i] == '.' {

			{{- if eq .DecimalLen 1 }}
			b = append(b, {{ .BaseLocale }}.decimal[0])
			{{- else }}
			for j := len({{ .BaseLocale }}.decimal) - 1; j >= 0; j-- {
				b = append(b, {{ .BaseLocale }}.decimal[j])
			}
			{{ end -}}
			{{- if gt .FmtNumberGroupLen 0 }}
			inWhole = true
			{{ end }}
			continue
		}

		{{ if gt .FmtNumberGroupLen 0 }}
		if inWhole {

			{{- if gt .FmtNumberSecondaryGroupLen 0}}
			
			if count == groupThreshold {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1

				if !inSecondary {
					inSecondary = true
					groupThreshold = {{ .FmtNumberSecondaryGroupLen }}
				}
			{{ else }}
			if count == {{ .FmtNumberGroupLen }} {
				{{- if eq .GroupLen 1 }}
				b = append(b, {{ .BaseLocale }}.group[0])
				{{- else }}
				for j := len({{ .BaseLocale }}.group) - 1; j >= 0; j-- {
					b = append(b, {{ .BaseLocale }}.group[j])
				}
				{{ end }}
				count = 1
			{{ end -}}
			} else {
				count++
			}
		}

		{{ end }}

		b = append(b, s[i])
	}

	if num < 0 {
		{{- if eq .MinusLen 1 }}
		b = append(b, {{ .BaseLocale }}.minus[0])
		{{ else }}
		for j := len({{ .BaseLocale }}.minus) - 1; j >= 0; j-- {
			b = append(b, {{ .BaseLocale }}.minus[j])
		}
		{{ end -}}
	}

	// reverse
	for i, j := 0, len(b)-1; i < j; i, j = i+1, j-1 {
		b[i], b[j] = b[j], b[i]
	}

	{{ if gt .FmtNumberMinDecimalLen 0 }}
	if int(v) < {{ .FmtNumberMinDecimalLen }} {

		if v == 0 {
			b = append(b, {{ .BaseLocale }}.decimal...)
		}

		for i := 0; i < {{ .FmtNumberMinDecimalLen }}-int(v); i++ {
			b = append(b, '0')
		}
	}
	{{ end }}

	return b
	{{ else }}
	return []byte(s)
	{{ end -}}
}

{{ end }}